[{"categories":["Spring"],"contents":"Spring Data Access Layer： JDBC \u0026gt; ORM \u0026gt; Transactions \u0026gt; OXM \u0026amp; JMS Web Layer： Servelt \u0026gt; WebSocket \u0026gt; Web \u0026gt; Portlet Infrascture： AOP \u0026gt; Aspects \u0026gt; Instructmentation \u0026gt; Messaging Test Layer： Unit \u0026gt; Integration \u0026gt; Mock\nInversion of Control (控制反轉)： 一個將物件建構和管理外包的方法，而這個過程將由物件工廠統一管理，讓物件不必主動建立，而是由該工廠替我們進行。 Spring Bean： 這其實也只是一個Java物件，當Java物件被Spring Container建立後，Spring就會把這些物件稱作Bean。\n\u0026ldquo;In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and otherwise managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your application. Beans, and the dependencies among them, are reflected in the configuration metadata used by a container.\u0026rdquo;\nDependency Injection： 將所需的 依賴實例，注入到高階模組中。\nDependecy Injection： Constructor Injection、 Setter Injection、Field Injection。 可以將常數外部化：使用.properties檔\nBean Bean LifeCycle Bean掃描機制：我們可以在註解後面指定Bean ID ，方便我們在後面BIND物件，若沒有指定Bean ID 則會有預設ID， ClassName 的字首變成小寫就是預設Bean ID。 Autowire Spring REST @PathVariable 該註解用於參數 Spring Boot Spring專案的開發往往會在初期遇到許多設定組態的問題，過程十分繁瑣複雜，而Spring Boot就是提供快速開發Spring專案的解決方案。 Spring Boot 已經將Tomcat寫在底層，因此不用再額外安裝伺服器。 Spring Boot依舊支援傳統型部署，例如以war檔案的形式部署在伺服器。\nSpring Boot 專案結構 src/main/java @SpringBootApplication 這個註解包含了下列三個註解：\n @EnableAutoConfiguration @ComponentScan @Configuration   基本上，application.java 一定是放在最外層的套件，方便@ComponentScan直接掃描下一層的所有套件。 如果你有其他結構不同的套件，可以在@SpringBootApplication 裡帶入 scanBasePacakages 屬性，合法值是 String []。 src/main/resources 預設上，Spring Boot 會自動從 application.properties 載入外部常數。該檔案會自動建立且不帶任何內容，並存放在 src/main/resources資料夾。 如果想在特定field注入特定常數，在該field加上 @Value，該屬性可以帶入一個字串值，合法值是application.properties裡面value pair 的 key。 表現形式：${key} HTML、CSS、JS、Image\u0026hellip;\u0026hellip;等等檔案會放在 src/main/resources/static。\n如果最後的部署檔案是JAR，請不要使用 src/main/webapp 路徑，他只會在部署檔案是WAR時有作用。 Templates Spring Boot 對下列 template引擎 有自動的組態設定\n FreeMaker Thymeleaf Mustache Spring Boot 會自動從 src/main/resources/templates 載入templates。  Spring Boot Actuator Spring提供的應用程式監控套件，加入這個套件後，會提供額外的REST終端，透過這個終端可以提供應用程式內部設定和狀態等資訊。\n/actuator/info 對這個終端發送GET請求，會回傳關於應用程式的INFO資訊，不過該回應預設是空的，使用者必須自行實作。可以在其中加入自己的商業邏輯。 Actuator提供的終端一覽 https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready-endpoints\n預設來說，只有 /health 和 /info 終端是暴露在外的，如果要修改相關設定，請在 applications.properties 加上下列設定： management.endpoints.web.exposure.include=*黑名單設定： management.endpoints.web.exposure.exclude=合法值Spring Boot Server Configuration 常用的可自定義屬性一覽： Spring Boot Core Properties\nExample\n  Log level config   Web config   Spring Boot JDBC Settings 以往需要透過XML 或是 Java Code 來設定 JDBC 的組態資訊，在SpringBoot，只需要將 JDBC URL、username、password 設定在application.properties 裡面就好。 SpringBoot Common Applications Properties (spring.datasource.*)\n根據組態設定，SpringBoot 會自動新建相關的beans (DataSource、EntityManager)。\nJava Persistence API (JPA)  ORM的標準API 需要實作相關介面才能使用 Hibernate 就是其實作之一。  JPA帶來的好處就讓用程式不被特定的ORM實作框架綁架，提高靈活性。 SringBoot預設的ORM實作是 Hibernate\nEntityManager 是一個跟 Hibernate SessionFactory很相似的物件，他也可以負責包裹 Hibernate Session 物件，我們可以將 EntityManager 物件注入到DAO。\nStandard JPA API  JPA API 方法和原生Hibernate API 高度相似 JPA 也有自己的查詢語言：JPQL (JPA Query Language)。   Spring Data JPA 減少DAO重複程式碼的解決方案。 Spring Data JPA Interface：JpaRepository 對於要做成DAO的類別，只需新增介面並繼承JpaRepository\u0026lt;你的ValueObject類別、Intrger(PK)\u0026gt;即可，Spring會自動生成相關的方法。 (也不需要@Repository) JpaRepository文件\n額外的特色：\n 可以用JPQL繼承或新增自定的Query 有自己的Query語言 - Query Domain Specific Language(Query DSL) 可定義自己的方法 (底層實作)  Defining Query Methods\n使用JpaRepository之後，在Service裡面不需要加註 @Transactional，因為JpaRepository自帶交易功能。\nSpring Data REST Spring Data REST 會自動掃描專案中的JpaRepository，並產生REST API給每個Enitiy type。 只需要在Spring Data JPA的基礎上，多新增一個 spring-boot-starter-data-rest 的 dependency。 如此不再需要Controller和Service。 對於Value Object的類別，其REST終端會將類別名稱字首小寫、後缀s來命名，比如 Employee類別，其對應的REST終端為 /employees。\n客製REST終端 但是如果有客製需求，可以在繼承JpaRepository的介面加入 @RepositoryRestResource 來設定，可帶入 path 屬性，其屬性合法值為字串，可以自行帶入想客製的REST終端名稱。 Pagination 預設一頁顯示20個元素。 可以透過查詢字串加入頁數參數來快速搜尋(0 based)。 其餘設定可以透過 Spring Boot Application Common Properties查看，spring.data.rest.*\nThymeleaf 一個獨立的框架，是一個 Java Template Engine，主要用來製作HTML並可以在其中使用 Thymeleaf 表達式。 相似於JSP，但 Thymeleaf 可用於非WEB環境。(EMAIL、CSV、PDF) 優點\n 可以用迴圈和情況判斷式 CSS和JS整合  ","permalink":"https://akechetaki10736.github.io/blog/spring/","tags":["Java","Spring"],"title":"Spring Framework學習筆記"},{"categories":["Hibernate"],"contents":"Hibernate 本質上是透過Java物件來操作SQL Table，因此在Java程式裡會有一個Entity類別(Pojo、Value Object)來對應一個SQL Table。\nHibernate Annotation 透過在Entity類別裡加入Hibernate註解來告訴Hibernate該屬性對應的SQL Column。 Entity類別必須是public。 Entity類別裡一定要有預設建構子或無引數 (Argument)建構子。 參數(Parameter)、引數(Argument)的差別 不可以是final類別，不可以有final方法。 資料成員不可以是public。 沒有finalize方法。\n在使用Hibernate時，應該import JPA套件，這是Hibernate Team的建議。 @Entity:宣告該類別為一個Entity類別。 @Table：可帶入value屬性，告訴Hibernate其對應的table名稱。 @Id：告訴Hibernate該屬性對應Table的PK。 @Column：可帶入name屬性，告訴Hibernate其對應的column名稱。 @GeneratedValue:可帶入strategy屬性，告訴Hibernate該如何產生值。\n   strategy屬性的可選值 描述     GenerationType.AUTO 讓Hibernate自動針對資料庫挑選合適的策略   GenerationType.IDENTITY 指派PK使用資料庫的identity column   GenerationType.SEQUENCE 指派PK使用資料庫的序列   GenerationType.TABLE 指派PK使用底層資料庫TABLE來確保其獨特性    你可以實作自己的Gentation Strategy 透過實作org.hibernate.id.IdentifierGenerator，Override generate(\u0026hellip;)。\nSessionFactory: 讀取Hibernate的設定檔(Config)、製造Session物件，由於本身是一個重量級(Heavy-Weight)物件，因此整個應用程式應該只能有一個。\nSession：用來包裹JDBC對於資料庫的連線，主要是用來儲存、載入物件的物件，生命週期短，從SessionFactory回收。\nAdvanced Mapping Entity Lifecycle One to One 舉例：講師 \u0026mdash;\u0026gt; 講師詳細資料 @OneToOne：可帶入cascade屬性，告訴Hibernate如何Cascade。 @JoinColumn：帶入name屬性，合法值為另一方類別在sql中的fk或pk欄位名稱。如果要實現雙向O2O，在另外一個class也要加上相對應的field、O2O和JoinColumn註解。 要新增被關聯表格的field，並將註解加在上方。 CascadeType One to Many 舉例： 講師 \u0026mdash;\u0026gt; 課程 在O2M中，要在多方裡新增一方的field，並加註@ManyToOne、@JoinColumn。 @ManyToOne：可帶入cascade屬性，告訴Hibernate如何Cascade。 @JoinColumn：帶入name屬性，合法值為另一方類別在sql中的fk或pk欄位名稱。 在O2M中，要在一方類別裡新增多方的集合(List)field，並加註@OneToMany。 @OneToMany：帶入mappedBy屬性，屬性合法值請帶入在多方類別中，一方field的名稱。\nFetchType FetchType可以在@ManyToOne、@OneToMany、@OneToOne\u0026hellip;\u0026hellip;等註解中帶入fetch屬性，來指定fetch的方式。\nLazy Loading 會先載入主要的Entity，有需求時才會載入其他的dependent Entites\nEager Loading 直接載入所有dependent Entites\nDefault FetchType 解決LazyLoading的問題  在session關閉前讀取資料 使用 HQL語法的 JOIN FETCH  ","permalink":"https://akechetaki10736.github.io/blog/hibernate/","tags":["Java","ORM","Hibernate"],"title":"Hibernate學習筆記"}]